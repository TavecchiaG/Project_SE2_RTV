\documentclass[10pt, a4paper,titlepage]{article}

\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{caption}
\usepackage[bottom]{footmisc}
\usepackage{textcomp}

\begin{document}
\begin{titlepage}
\title{Integration Testing Document \\Version 1.1}
\author{Emanuele Ricciardelli (mat. 875221) \and Giorgio Tavecchia (mat. 874716) \and Francesco Vetr\'o (mat. 877593)}
\begin{figure}
\begin{center}
\includegraphics{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/logopolimi.png}
\caption{Politecnico di Milano}
\label{fig:logo}
\end{center}
\end{figure}
\maketitle
\end{titlepage}
\tableofcontents
\pagebreak
\section{Introduction}
\subsection{Purpose}
This document represents the Integration Testing Plan Document for PowerEnJoy service.
The purpose of the testing is to verify and ensure that the system operation is correct and complies with all the requirements expressed in the previous documents (RASD and DD). All components of the system will have to comply with the constraints and functionalities for which they were designed, without showing unexpected behavior.
The purpose of this document resides therefore in specifying the methods and the time needed to complete a full testing, both from the point of view of the individual components, both in their interactions.
In order to provide a detailed description of the future testing, in the following paragraphs it will be defined:
\begin{itemize}
\item A list of the subsystems and their subcomponents of the PowerEnJoy system-to-be that will be involved in the testing activity;
\item The criteria that must be met by the project status before integration testing of the outlined elements may begin;
\item A description of the integration testing approach and the rationale behind the specific choose;
\item The sequence of component and function integration;
\item A description of individual steps and test description: for each step of integration, we will define a test design with related expected results for each test;
\item A list of tools, test equipment and test data required.
\end{itemize}•
\subsection{Definitions and Abbreviations}
\begin{itemize}
\item RASD: Requirement Analysis and Specification Document;
\item DD: Design Document;
\end{itemize}•
\emph{For all other definitions, please refer to previous documents listed in the next paragraph}
\subsection{Reference Documents}
\begin{itemize}
\item Specification document: Assignments AA 2016-2017.pdf
\item RASD Version 1.1
\item DD Version 1.1
\item Integration testing example document.pdf
\end{itemize}•
\section{Integration strategy}
\subsection{Entry criteria}
With reference to the past documents and in particular to the design document, it is necessary to specify how the individual components that make up the system require to achieve a given percentage of completion with respect to the features for which they were designed.
Especially, with respect to the High Level Component view of the Design Document:
\begin{itemize}
\item 100\% for the DBMS component: in order to allow a correct testing not only of the database structure itself, but also of the various components of the system that base their operation on access to the database;
\item 60\% of the Client components: many of the functions covered by the client involve the GUI and have no priority over interaction with the system functionality;
\item 90\% of the Application Server;
\item 90\% of the Car Sensor Subsystem: in order to ensure a correct testing of the application server, given the close interaction.
\end{itemize}•
These criteria must be met before the start of the Integration testing. Different percentages want to reflect the order of integration, placed its focus on certain components, and otherwise in the background some secondary aspects such as the graphical user interface on the client.
\subsection{Elements to be integrated}
In order to specify the elements to be integrated, we refer not only to High Level Component view contained in the DD, but also to the Component view that allows us to identify components at a lower level and the relationships between them .
As specified in the Design Document, the components of our system have been designed in such a way as to ensure a high level of modularity, by separating the different functionality into distinct components, thus also facilitating testing.
For this reason, right from the Component view it is possible to note how different components are strongly dependent on one another in order to achieve more complex functionality of the system-to-be.
The recognition of these complex functionality allows us to split our system into a number of subsystems, addressed respectively to the access management and registration system (\emph{Account Subsystem}), management of payments (\emph{Payment subsystem}), reservation management and everything that concerns the sphere of rental (\emph{Reservation subsystem}) and finally management of all the sensors and the exchange of information between cars and system and everything related to the maintenance (\emph{Car / Sensors subsystem}).
In particular, the functions relating to the \emph{Reservation subsystem} will involve the integration of:
\begin{itemize}
\item Reservation Controller;
\item Ride Controller (integrated with Google Maps API);
\item Notification Helper (with related gateway);
\item Communication Manager;
\item Request Manager;
\item Data Access Manager.
\end{itemize}•
With respect to the \emph{Account subsystem}, it is concentrated only in the \emph{Login / Registration Controller} that later, through the \emph{Communication Manager}, will interface with the other components of the PowerEnJoy system. In detail:
\begin{itemize}
\item Login/Registration Controller;
\item Communication Manager;
\item Request Manager;
\item Notification Helper (with related gateway);
\item Data Access Manager.
\end{itemize}•
The same reasoning can be made for the \emph{Payment subsystem} and the respective \emph{Payment Controller}. In detail:
\begin{itemize}
\item Request Manager;
\item Payment Controller;
\item Communication Manager;
\item Data Access Manager;
\item Payment Gateway;
\end{itemize}
Finally, the \emph{Car / Sensors subsystem} in order to perform all its functionalities will need to integrate:
\begin{itemize}
\item Cars Controller;
\item Communication Manager;
\item Collector Data (with related gateway);
\item Maintenance Gateway;
\item Request Manager;
\item Data Access Manager;
\end{itemize}•
It is important to underline that the components \emph{Notification Helper} \emph{Request Manager} and \emph{Communication Manager} are significant for all subsystems and therefore their integration. This means that if on the one hand their presence ensures greater flexibility in the management of functions, on the other hand emphasizes the importance of their proper functioning in order to ensure the fulfillment of all the functionality of the overall system.
Given the above definitions of subsystems, our integration testing will proceed initially considering a single subsystem at a time, following finally with the integration of the same until the establishment of the system in its entirety.
\subsection{Integration testing strategy}
The approach suggested in the process of integration testing is bottom-up.
This choice is based on considerations relating to the features covered by our system: in particular, as has been documented in the DD, it has been chosen to decompose the system into a series of components, each with features related to a particular field. The functionalities that the system will perform are derived from joint work of these components. From this observation it can be seen that the choice of a bottom-up reflects the needs of the testing related to our system.
In this way we can favour the ability to identify problems at an early stage of development of the components and, in case, to react quickly. 
Later, after having tested the elementary interactions between components and subsystems, we can proceed with the integration to a higher level.
It will therefore be necessary to develop a set of drivers to drive the testing, but given the simultaneous development of the overall system, this will prove to be quite natural.
Once the system will be completely formed, we shall provide the implementation of a series of System Testing in order to verify not only the achievement of the functional requirements, as a whole, but also of the non-functional aspects such as the loading capacity as a function of the expected values.
\subsection{Sequence of component / function integration}
In this section we will provide a description of the order of integration testing of components and subsystems of PowerEnJoy system-to-be.
\subsubsection{Software integration sequence}
Given the previous subdivision into subsystems and starting from the \emph{Reservation subsystem}, we now define the sequence in which the components will be integrated for each subsystem and then the sequence related to the integration of the subsystems themselves.
\paragraph{Reservation subsystem}\mbox{}\\
Since many features covered by this system need an interaction with the database (performing queries or updating tables), the very first components to be integrated are the \textbf{Data Access Manager} and the \textbf{DBMS}.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.2\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence1.png}
\caption{Integration sequence - 1 - Data Access Manager, DBMS}
\label{fig:int_seq1}
\end{center}•
\end{figure}
\linebreak
As will later be made clear, this first integration will also be required for other subsystems, but will not be repeated if it is unnecessary; otherwise it will be repeated the possible variants of integration between these first components and the surrounding ones.
With respect to the bottom-up approach, the next integration step will cover the correct communication between the database and the \textbf{Communication Manager}.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.3\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence2.png}
\caption{Integration sequence - 2 - Communication Manager \& above}
\label{fig:int_seq2}
\end{center}•
\end{figure}
\linebreak
We can now proceed to a higher level of integration considering the \textbf{Ride Controller}:
this component will be integrated with the API provided by the services of google in order to verify the correct use within their own methods, with the "Notification Helper" in order to verify the correct sending of notifications generated to users, and finally with \textbf{Communication Manager} which, as described in the DD, is designed to allow (in a flexible and transparent way) the exchange of information between internal components of the system, to verify proper access to the database.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence3.png}
\caption{Integration sequence - 3 - Ride Controller, Notification Helper, Google APIs \& above}
\label{fig:int_seq3}
\end{center}•
\end{figure}
At the same level of integration we will introduce the \textbf{Reservation Controller} integrated with \textbf{Communication Manager} and \textbf{Notification Helper} for the same reasons mentioned above.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence4.png}
\caption{Integration sequence - 4 - Reservation Controller \& above}
\label{fig:int_seq4}
\end{center}•
\end{figure}
\clearpage
Since different functions performed by the controller such as \textbf{Reservation Controller} and \textbf{Ride Controller} are performed by request from external clients, and given that the same demands are made through the component \textbf{Request Manager}, the next components to be integrated will be the following.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.5\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence5.png}
\caption{Integration sequence - 5 - Request Manager \& above}
\label{fig:int_seq5}
\end{center}•
\end{figure}
\clearpage
This will make it possible to test the correct routing of requests towards the selected components and the exchange of information between them.
Finally we integrate the Client, to test that all of the functionalities of this subsystem work properly.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.5\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence6.png}
\caption{Integration sequence - 6 - Client \& above}
\label{fig:int_seq6}
\end{center}•
\end{figure}
\clearpage
\paragraph{Account subsystem}\mbox{}\\
The starting point relative to the sequence of integration of this subsystem should be regarding the access to the database, but, as previously expressed, since it was done for the previous subsystem, it is not required to do it again. It is now shown for the sake of completeness to the reader.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.2\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence1.png}
\caption{Integration sequence - 1 - Data Access Manager, DBMS}
\label{fig:int_seq1_1}
\end{center}•
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.3\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence2.png}
\caption{Integration sequence - 2 - Communication Manager \& above}
\label{fig:int_seq2_1}
\end{center}•
\end{figure}
\pagebreak
\linebreak
We follow now with the integration between the \textbf{Login / Registration Controller} and \textbf{Notification Helper} to verify, as done in the previous subsystem, the correct forwarding of notifications generated and, at the same time, integrating  the \textbf{Login / Registration Controller} with \textbf{Communication Manager} and \textbf{Data Access Manager} in order to test the proper functioning of methods that require database access.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence7.png}
\caption{Integration sequence - 7 - Login/Registration Controller, Notification Helper \& above}
\label{fig:int_seq7}
\end{center}•
\end{figure}
\linebreak
Going up to a higher level of integration, we introduce the \textbf{Request Manager} in order to test the correct routing of requests coming from the outside to the component suited to the management of the system accounts.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence8.png}
\caption{Integration sequence - 8 - Request Manager \& above}
\label{fig:int_seq8}
\end{center}•
\end{figure}
And again we terminate this sequence of integration introducing the Clients to test that all of the functionalities of this subsystem work properly.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence9.png}
\caption{Integration sequence - 9 - Client \& above}
\label{fig:int_seq9}
\end{center}•
\end{figure}
Thus completing the integration of this subsystem.
\clearpage
\paragraph{Payment subsystem}\mbox{}\\
We now proceed in the integration process Considering the \emph{Payment Subsystem}.
As before, we start integrating the components related to the access to the database.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.2\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence1.png}
\caption{Integration sequence - 1 - Data Access Manager, DBMS}
\label{fig:int_seq1_2}
\end{center}•
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.3\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence2.png}
\caption{Integration sequence - 2 - Communication Manager \& above}
\label{fig:int_seq2_2}
\end{center}•
\end{figure}
\pagebreak
The first components that need to be integrated are the \textbf{Payment Controller} and the \textbf{Payment Gateway}, this to verify that the results relating to payment functions are correctly sent to the external payment companies, and the integration between \textbf{Payment Controller} and \textbf{Communication Manager} to test the communication with the database.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.3\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence10.png}
\caption{Integration sequence - 10 - Payment Controller, Payment Gateway \& above}
\label{fig:int_seq10}
\end{center}•
\end{figure}
\linebreak
Followed by the integration with the \textbf{Request Manager} to verify the correct forwarding of information requests to the subsystem.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence11.png}
\caption{Integration sequence - 11 - Request Manager \& above}
\label{fig:int_seq11}
\end{center}•
\end{figure}
As before we terminate this sequence of integration testing the connection with the Client.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence12.png}
\caption{Integration sequence - 12 - Client Payment System \& above}
\label{fig:int_seq12}
\end{center}•
\end{figure}
\clearpage
\paragraph{Car / Sensors subsystem}\mbox{}\\
The last subsystem to be included in the sequence of integration is the \emph{Car / Sensors subsystem} that will handle all exchanges of information and operations to be performed on vehicles and everything related to the maintenance.
The starting point is still represented by the access to database.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.2\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence1.png}
\caption{Integration sequence - 1 - Data Access Manager, DBMS}
\label{fig:int_seq1_3}
\end{center}•
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.3\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence2.png}
\caption{Integration sequence - 2 - Communication Manager \& above}
\label{fig:int_seq2_3}
\end{center}•
\end{figure}
\clearpage
As first components to be integrated, we choose \textbf{Cars Controller} and \textbf{Data Collector}: this choice derives from the importance that covers the proper exchange of information between system and machine, upon which are based a considerable number of other functions related to the \textbf{Cars Controller} itself. In addition we integrate our principal component with the \textbf{Maintenance Gateway}  to test the proper sending of information from the system to the maintenance company and with the \textbf{Communication Manager} to verify the correct access with the database.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence13.png}
\caption{Integration sequence - 13 - Cars Controller, Collector Data, Maintenance Gateway \& above}
\label{fig:int_seq13}
\end{center}•
\end{figure}
\linebreak
Finally the sequence of integration will end integrating the \textbf{Request Manager} and so to verify the correct implementation of functionalities such as reporting a fault to a machine or access by the maintenance to the list of reported cars.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence14.png}
\caption{Integration sequence - 14 - Request Manager \& above}
\label{fig:int_seq14}
\end{center}•
\end{figure}
As last integration, like in other subsystems, we verify and test the integration with the clients.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence15.png}
\caption{Integration sequence - 15 - Clients \& above}
\label{fig:int_seq15}
\end{center}•
\end{figure}
\clearpage
\emph{\underline{Note to the reader}}: In previous integration sequences it was performed a choice concerning the gateway present in the component view of the DD: we decide to show explicitly only the payment and maintenance gateway. This is because the integration of the omitted gateway is to consider joint with the components to which they are directly linked: For example, the \textbf{\sout{Sensor} Cars Gateway} is considered as a joint to the component \textbf{\sout{Data Collector} Collector Data} and the gateway relative to the notifications joint with the \textbf{Notification Helper}.
\pagebreak
\subsubsection{Subsystem integration sequence}
In order to recreate from the subsystems, considered in the previous section, the overall system, the process of integration will initially proceed by integrating the \textbf{Reservation Subsystem} with \textbf{Car / Sensor Subsystem} in order to test all of those functions of the first subsystem that require access to the functionality provided by the second.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.8\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence16.png}
\caption{Integration sequence - 16 - Clients \& above}
\label{fig:int_seq16}
\end{center}•
\end{figure}
\linebreak
It is now integrated  the \textbf{Account Subsystem}in order to test the integration of external user and system, through all the features that will provide PowerEnjoy to it, excluding those relating to payments that are later tested with the integration of the related subsystem.
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence17.png}
\caption{Integration sequence - 17 - Clients \& above}
\label{fig:int_seq17}
\end{center}•
\end{figure}
\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth, height=0.4\textheight, keepaspectratio]{/home/francesco/git/Project_SE2_RTV/Integration_Testing/TEST_images/Integration_Sequence18.png}
\caption{Integration sequence - 18 - Clients \& above}
\label{fig:int_seq18}
\end{center}•
\end{figure}
\clearpage
\section{Individual steps and test description} \label{sec3}
In this section we would describe, according to the Component Interfaces (see DD at Section 2.6), how the interaction between the various components of your system is tested, using the properly interfaces provided by us in order to get this purpose. The description is made by going through the different subsystems and for each of that, focusing on their working and describing in an accurate way what are the methods used to reach the scope. For each method described, we give a brief description on what are the possible inputs values and the respective effect expectation.
\subsection{External calling}
With external calling we mean one of various type of Client that we described in the Component View (Client, Maintenance System or Payment System). Each of that, in the request phase, performs and sends a new request to our system. It is processed by the Request Manager. The request type specified below is generic (abstract superclass) and different types of requests exist (Client has ClientRequest, Maintenance has MaintenanceRequest and so on).
\subsubsection{Client (generic), Request Manager}
This test is done to verify that the request manager can receive correctly an admissible request and that it is able to handle this in order to be dispatched to the correct component.
\begin{table}[h]
\caption{sendRequest(request:Request)}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
One of the request type cited above & The request is processed by proper policies, depending on the request type and it is ready to be dispatched.\\
\hline
\end{tabularx}
\end{table}
\subsection{Reservation subsystem}
\subsubsection{Communication Manager, Data Access Manager} \label{sssec3.2.1}
This test is made to verify that the Data Access Manager can parse the string received by the Communication Manager as a query and if the component can perform it properly returning the correct instance of Model required by the query submitted.
\begin{table}[h]
\caption{sendQuery(query: String):Model}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A string not parsed in a Query Language & A InvalidArgumentException is thrown.\\
\hline
Valid query string & The Data Access Manager performs the query on the Database and returns the proper instance of the Model class (or its subclass) based on what the query asks.\\
\hline
\end{tabularx}
\end{table}
This test is made to verify that the Data Access Manager can parse the string received by the Communication Manager as an updating query and if the component can perform it properly returning the outcome of the operation.
\begin{table}[h]
\caption{sendUpdate(query: String):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A string not parsed in a Query Language & A InvalidArgumentException is thrown.\\
\hline
A string not parsed in a updating instruction & A InvalidArgumentValueException is thrown\\
\hline
Valid query string & The Data Access Manager performs the updating on the Database and returns true if it succeed, otherwise false.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\subsubsection{Reservation Controller, Communication Manager}
This test is made to verify that the Communication Manager can perform the Method sent by Reservation Controller in a proper way in order to perform the desired effect on the system.
\begin{table}[h]
\caption{executeRemoteMethod(method: Method):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A method that is not listed in the class & Return false\\
\hline
Valid method & The Communication Manager dispatches the method come from the reservation and performs the proper action, described by the parameter passed. \\
\hline
\end{tabularx}
\end{table}
\pagebreak
\subsubsection{Ride Controller, Communication Manager}
This test is made to verify that the Communication Manager can perform the Method sent by Ride Controller in a proper way in order to perform the desired effect on the system.
\begin{table}[h]
\caption{executeRemoteMethod(method: Method):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A method that is not listed in the class & Return false\\
\hline
Valid method & The Communication Manager dispatches the method come from the RideController and performs the proper action, described by the parameter passed.  \\
\hline
\end{tabularx}
\end{table}
\subsubsection{Request Manager, Reservation Controller}
This test is made to verify that the reservation controller can validate the input received by the request manager and it is able to create a new valid instance of reservation using the user informations passed by the previous component.
\begin{table}[h]
\caption{newReservation(user: User, carPlate: String):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A not existing user & A InvalidArgumentException is thrown\\
\hline
A user suspended from the service & A UserSuspendedException is thrown. \\
\hline
A not existing car & A InvalidArgumentException is thrown\\
\hline
Valid informations & Reservation Controller, first retrieves the car’s data according to the carPlate passed, then creates a new instance of reservation and fills it with the information received as parameters. A new instance is saved in a permanent way to the database.\\
\hline
\end{tabularx}
\end{table}
\clearpage
This test is made to verify that the Reservation Controller can retrieve the last reservation performed by a specific user and show it to the client.
\begin{table}[h]
\caption{showLastReservation(user: User): void}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A not existing user & A InvalidArgumentException is thrown\\
\hline
A user that hasn’t performed a reservation yet & A InvalidArgumentValueException is thrown. \\
\hline
Valid informations & Reservation Controller creates a properly method instance to do the query on the database for retrieving the user’s last reservation. At the end, it shows the informations. \\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the reservation controller can extend correctly its duration.
\begin{table}[h]
\caption{extendReservation(reservationId: Int, user: User, carPlate: String): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
Valid informations & Reservation Controller, first retrieves the reservation instance related to the input’s parameter, then modifies the information concerning the ending time extending its duration and it updates the record on the database, through  a proper Method instance.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the reservation controller can delete the reservation passed.
This test is made to verify that the reservation controller can extend correctly its duration.
\begin{table}[h]
\caption{deleteReservation(reservationId: Int, user: User, carPlate: String): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
Valid informations & Reservation Controller deletes the record that corresponds to the input’s parameter on the database , through a proper Method instance.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\linebreak
This test is made to verify that the reservation controller can perform the code generator  algorithm to provide the QR Code for unlocking the car reserved.
\begin{table}[h]
\caption{showUnlockCode(reservationId: Int, user: User, carPlate: String): Code}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
Valid informations & Reservation Controller, first retrieves the reservation instance related to the input’s parameter, then performs the unlocking code by the algorithm devoted to it and explained in Design Document (ER Diagram section) and returns it.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the reservation controller can perform the distance algorithm in order to providing a suitable list of reservable cars.
\begin{table}[h]
\caption{retrieveCarsPosition(position: Position, range: Int) : List<Car>}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
An invalid position & A InvalidArgumentException is thrown\\
\hline
A nonpositive range & A InvalidArgumentValueException is thrown\\
\hline
Valid informations & Reservation Controller retrieves the list of available cars from the database and performs a specific algorithm to filter them according to their last position. At the end, it returns the filtered list\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsubsection{Notification Helper, Push Gateway} \label{sssec3.2.5}
This test is made to verify that the Push Gateway notifies correctly the client’s device using push notification.
\begin{table}[h]
\caption{sendMessage(message: Message) : boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
An empty message & A InvalidArgumentValueException is thrown\\
\hline
Valid parameter & Push Gateway notifies the Client device through push notification reporting the string message contained in the Message passed.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsubsection{Notification Helper, Email Gateway} \label{sssec3.2.6}
This test is made to verify that the Email Gateway notifies correctly the client’s device using email notification.
\begin{table}[h]
\caption{sendMessage(message: Message) : boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
An empty message & A InvalidArgumentValueException is thrown\\
\hline
Valid parameter & Email Gateway notifies the Client application through email notification reporting the string message contained in the Message passed.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsubsection{Reservation Controller, Notification Helper}
This test is made to verify that the Notification Helper is able to handles correctly the information passed by Reservation Controller and can create and send a proper message to the right gateway.
\begin{table}[h]
\caption{sendNotification(notification: Notification): void}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
Valid parameter & Notification Helper handles the notification containing the information to be sent to the client, creates a proper message and send it through the right gateway.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsubsection{Ride Controller, Notification Helper}
This test is made to verify that the Notification Helper is able to handles correctly the information passed by Ride Controller and can create and send a proper message to the right gateway.
\begin{table}[h]
\caption{sendNotification(notification: Notification): void}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
Valid parameter & Notification Helper handles the notification containing the information to be sent to the client, creates a proper message and send it through the right gateway.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsection{Account Subsystem}
\subsubsection{Communication Controller, Data Access Manager}
See section \ref{sssec3.2.1}.
\subsubsection{Login/Registration Controller, Communication Manager}
This test is made to verify that the Communication Manager can perform the Method sent by Login/Registration Controller in a proper way in order to perform the desired effect on the system.
\begin{table}[h]
\caption{executeRemoteMethod(method: Method)}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A method that is not listed in the class & Return false\\
\hline
Valid method & The Communication Manager dispatches the method come from the Login/Registration Controller and performs the proper action, described by the parameter passed.\\
\hline
\end{tabularx}
\end{table}
\subsubsection{Notification Helper, Push Gateway}
See section \ref{sssec3.2.5}
\subsubsection{Notification Helper, Email Gateway}
See section \ref{sssec3.2.6}
\subsubsection{Login/Registration Controller, Notification Helper}
This test is made to verify that the Notification Helper is able to handles correctly the information passed by Login/Registration Controller and can create and send a proper message to the right gateway.
\begin{table}[h]
\caption{sendNotification(notification: Notification): void}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
Valid parameter & Notification Helper handles the notification containing the information to be sent to the client, creates a proper message and send it through the right gateway.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsubsection{Request Manager, Login/Registration Controller}
This test is made to verify that the Login/Registration Controller is able to create a new stable session with the user’s data retrieved by the database in order to allow him for performing actions.
\begin{table}[h]
\caption{login(password:String): User}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\ 
\hline
A not existing password in the database & Return false\\
\hline
Valid password & The Login/Registration Controller retrieves all data referred by the password inserted in order to execute efficiently the next operations, so it creates a new session with the data for keeping track on the system about the user connection. The User instance is returned to the caller in order to give the possibility to save it into a suitable collection and to associate it to the respective session ID.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Login/Registration Controller is able to delete the Session of the logging out user.
\begin{table}[h]
\caption{logout(sessionId: int): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
Valid parameter & The Login/Registration Controller deletes the session related to the user that has requested to be logged out. It returns false if problems occur.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Login/Registration Controller is able to create a new User.
\begin{table}[h]
\caption{registration(name: String, surname: String, drivingLicense: String, email:String,paymentMethod:String): String}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A driving license that already exists & Return false\\
\hline
Valid credentials & The Login/Registration Controller creates a new instance of User and inserts it into the database, then it sends the password to the user through an email (using the Notification Helper).\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\linebreak
\subsection{Payment subsystem}
\subsubsection{Communication Controller, Data Access Manager}
See section \ref{sssec3.2.1}
\subsubsection{Payment Controller, Communication Manager}
This test is made to verify that the Communication Manager can perform the Method sent by Payment Controller in a proper way in order to perform the desired effect on the system.
\begin{table}[h]
\caption{executeRemoteMethod(method: Method)}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A method that is not listed in the class & Return false\\
\hline
Valid method & The Communication Manager dispatches the method come from the Payment Controller and performs the proper action, described by the parameter passed.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\clearpage
\subsubsection{Request Manager, Payment Controller}
This test is made to verify that the Payment Controller is able to retrieves correctly the user and his list of pending payments.
\begin{table}[h]
\caption{showPendingPayments(userPaymentID: int) : List<Payment>}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A wrong userPaymentID & A InvalidArgumentValueException is thrown\\
\hline
Valid ID & The Payment Controller performs the specific algorithm for converting the ID passed by the Payment society’s system in order to retrieve the related User and then it checks if he has pending payments on the database. If he hasn’t, it returns null, otherwise it returns the pending payments as a list.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Payment Controller is able to update a payment record on the database.
\begin{table}[h]
\caption{updatePayment(payment: Payment): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing payment in the database & A InvalidArgumentValueException is thrown\\
\hline
Valid payment & The Payment Controller updates the related payment record in the database.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsubsection{Payment Controller, Payment Gateway}
This test is made to verify that the Payment Controller is able to send correctly the message to the payment company.
\begin{table}[h]
\caption{sendMessage(message: Message) : boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
Valid payment & The Payment Gateway sends the message, properly prepared by the Payment Controller, to the payment company. It returns false if an issue occurs, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\linebreak
\subsection{Car subsystem}
\subsubsection{Communication Controller, Data Access Manager}
See section \ref{sssec3.2.1}
\subsubsection{Cars Controller, Communication Manager}
This test is made to verify that the Communication Manager can perform the Method sent by Cars Controller in a proper way in order to perform the desired effect on the system.
\begin{table}[h]
\caption{executeRemoteMethod(method: Method)}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A method that is not listed in the class & Return false\\
\hline
Valid method & The Communication Manager dispatches the method come from the Cars Controller and performs the proper action, described by the parameter passed. \\
\hline
\end{tabularx}
\end{table}
\subsubsection{Collector Data, Car Gateway}
This test is made to verify that the Car Gateway can catch the message arrived by external systems and can decide to which component delivers it.
\begin{table}[h]
\caption{receiveAndDispatchMessage():Message}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
Nothing & The Car Gateway taps the message from the external system and it dispatches it to the proper component (in this case, the Collector Data) by a return.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Car Gateway can send correctly the message passed by the Collector Data.
\begin{table}[h]
\caption{sendMessage(message:Message):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
Valid message & The Car Gateway sends the message to the right external addressee. It returns false if an issue occurs, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\subsubsection{Cars Controller, Collector Data}
This test is made to verify that the Collector Data is able to elaborate the message arrived by external systems in order to extracts useful data.
\begin{table}[h]
\caption{retrieveData(message: Message): Collection $\langle Data \rangle$}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
Valid message & The Collector Data elaborates the message and extracts the data contained into it. It puts what extracted into a Collection and it sends it to the Cars Controller.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Collector Data is able to create a proper message for the car’s external systems using a list of data passed.
\begin{table}[h]
\caption{createMessage(car: Car, data: List $\langle Data \rangle$) : void}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing car & An InvalidArgumentException is thrown\\
\hline
Valid parameters & The Collector Data creates a suitable message using the list of data passed by Cars Controller, then the message is sent to the car’s external system indicated by the Car instance.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Cars Controller is able to check if the code caught by the car’s sensors is equal to that has been associated in the registration phase for that specific car and id it can unlock correctly the car.
\begin{table}[h]
\caption{checkUnlockCode(code: Code): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
Valid parameters & The Cars Controller checks if the QR Code read by the car’s system corresponds to the code associated to that specific car in a valid registration phase, by reading on the database. If the correspondence occurs, it return true and the car will be unlocked, otherwise false.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\subsubsection{Cars Controller, Maintenance Gateway}
This test is made to verify that the Maintenance Gateway can send correctly the message passed by the Cars Controller.
\begin{table}[h]
\caption{sendMessage(message:Message):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
Valid message & The Maintenance Gateway sends the message to the right external addressee. It returns false if an issue occurs, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\subsubsection{Request Manager, Cars Controller}
This test is made to verify that the Cars Controller can retrieve correctly the list of maintenance records store on the database.
\begin{table}[h]
\caption{getReportedCars(): List$\langle MaintenanceRecord \rangle$}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
Nothing & The Cars Controller retrieves all the maintenance record related to cars which are waiting assistance. It puts them into a list and it returns that.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Cars Controller can updates a maintenance record stored on the database with data passed by the Maintenance society’s external system.
\begin{table}[h]
\caption{updateMaintenanceRecord(mr: MaintenanceRecord):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing record in the database & An InvalidArgumentException is thrown\\
\hline
Valid record & The Cars Controller updates the maintenance record on the database. If an issue occurs, it returns false, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\linebreak
This test is made to verify that the Cars Controller can open and save correctly a new report performed by the maintenance employee.
\begin{table}[h]
\caption{openReportIssue(carPlate: String , description: String): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A car's plate referred to a not existing car & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Cars Controller, first retrieves the car’s information from the database, then creates a new instance of MaintenanceRecord based on the parameters and inserts it into the database. If an issue occurs, it returns false, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\subsection{Subsystem interconnection and communication}
This last section is devoted to show the testing of the interconnection and the communications among the subsystems listed above in order to pursuit the system’s scope and to perform its functionalities.
\subsubsection{Ride Controller, Communication Manager, Cars Controller (Cars subsystem, Reservation subsystem)}
This test is made to verify that the Reservation Controller can terminate correctly a reservation when a ride related to it is started.
\begin{table}[h]
\caption{completeReservation(reservation: Reservation): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing reservation & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Reservation Controller updates on the database the record referred to the reservation passed as parameter in order to mark it completion, so updating the endingTime attribute. If an issue occurs return false, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\subsubsection{Ride Controller, Communication Manager, Cars Controller (Cars Subsystem, Reservation Subsystem)}
This test is made to verify that the Cars Controller can check if the car referred to the Car instance passed by the Ride Controller is plugged or not.
\begin{table}[h]
\caption{isPlugged(car: Car): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing car & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Cars Controller’s subsystem checks if the car reported by the Car instance is plugged through its sensors. It returns true if it’s plugged, otherwise false.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Cars Controller can check the battery charge level of a given car.
\begin{table}[h]
\caption{getCharge(car: Car): Int}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing car & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Cars Controller’s subsystem queries the car’s sensors indicated by the Car instance  to get the level of battery charge. It returns the value.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Cars Controller can correctly retrieve the position of a given car.
\begin{table}[h]
\caption{getPosition(car: Car): Area}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing car & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Cars Controller’s subsystem checks if the car’s engine is off, then it queries the database retrieving the informations about where the car is left when the ride before is finished, otherwise it retrieves the car’s position using the GPS system located on the vehicle. It returns the Area’s information based on the fact explained above.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\linebreak
This test is made to verify that the Ride Controller can create a new Ride when a Cars Controller observes that the engine of a reserved car is turned on.
\begin{table}[h]
\caption{newRide(reservation: Reservation): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing reservation & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Ride Controller creates a new instance of Ride and fills it with the informations concerning the associated reservation, then it inserts it into the database.
If an issue occurs, it returns false, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\linebreak
This test is made to verify that the Ride Controller can correctly mark as finished a specific ride.
\begin{table}[h]
\caption{completeRide(ride: Ride): boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A not existing ride & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Ride Controller updates specific attributes (for example, ride’s ending Time, in which safe area it is parked and so on) of the record situated on the database and related to the parameter passed in order to mark the ending of that existing ride. Since that moment, that specific car is unreserved and it is ready to be reserved again. If an error occurs, it returns false, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\subsubsection{Ride Controller, Communication Manager, Payment Controller (Payment Subsystem, Reservation Subsystem)}
This test is made to verify that the Payment Controller is able to notify correctly the Payment Society about a new pending payment concerning a finished ride.
\begin{table}[h]
\caption{sendPayment(payment: Payment):boolean}
\begin{tabularx}{\textwidth}{|>{\hsize=.4\hsize}X|>{\hsize=.6\hsize}X|}
\hline
Input & Effect on the system\\
\hline
A null parameter & A NullPointerException is thrown\\
\hline
A payment referred to a not existing ride or not existing user & An InvalidArgumentValueException is thrown\\
\hline
Valid parameter & The Payment Controller’s subsystem sends the payment request to the Payment society’s external system in order to notify them about a new payment to enforce. If an error occurs, it returns false, otherwise true.\\
\hline
\end{tabularx}
\end{table}
\pagebreak
\section{Tools and test equipment required}
\subsection{Test tools}
Testing for the PowerEnJoy system-to-be will be splitted in three main parts:
\begin{itemize}
\item Business logic components: in order to tackle testing of this section of the system, the two main tools that will be used are Arquillian integration testing framework and the JUnit framework. The first one is specifically designed for checking the execution of a component with respect to the surrounding environment. In this specific system, its functionalities will be used to verify that communication with database and how the communication flow is performed by the system with respect to what was expected. JUnit framework will be used for both the purpose of unit testing in combination with test coverage assist like Sonarqube, and its potentiality will be adapted to integration testing with respect to the correctness of responses that the various component give back when an error and exceptions occur;
\item Mobile applications: the mobile application must be tested with respect of CPU and memory usage and energy consumption. This could be done by specific tools within the SDK of the platform target of testing;
\item Validation, certification and standardisation for web pages: W3C is the specific tool for validating the system-to-be web code related to the user experience. Our aim with this kind of testing is to generate a product that will target the most wide pool of potential users and therefore clients.
\end{itemize}•
\subsection{Test equipment}
In order to perform the entire test process proposed in the previous sections, we have chosen to stipulate a contract with a Cloud provider for hiring computational environment. 
Then we could use a cloud service like Platform as a Service (PaaS) in order to perform our test plan, including the integration test.
This choice has been done because the cloud computing is a very cheap way to get computational power and also because our future intention (explained on the Design Document - Overview), after the first official release, is to move the system onto a cloud infrastructure, therefore the PaaS allows us to feel and to measure what will be the performances of our system running on this type of infrastructure, before the deployment; in addition, performing the test on an architecture of this kind allows us to make scalable tests, in order to undergo the system with incremental workloads. Once obtained the computational infrastructure, we will use those devices which will be implied by users to interact with our system: we’re referring to mobile phone devices (with various O.S. installed like iOS, Android, Windows Phone and so on) and Personal Computers in order to test the interaction between different types of clients and our system and also for testing how the system’s responses are elaborated by those clients and how they are visualized. This kind of tests can be completed by using at full extent the tools that some development kits offer: the idea is to simulate different scenarios via this tools in order to check whether the performances, both visually and system-related, are matched and the correctness of the service erogated. 
\section{Required program driver and test data}
\subsection{Program driver and stubs}
As stated before in this document, we are going to follow a bottom-up approach for integration testing. This decision leads to the necessity of creating the needed set of drivers in order to perform the identified tests pools, in particular we will construct drivers for each module, excluding those coming from third parties, as the DBMS and the API provided by the Google services. Hereafter is a list of drivers necessary to test the integration of the system-to-be:
\begin{itemize}
\item \textbf{Data Access Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Data Access Manager} in order to test its interaction with the DBMS. We emphasize that the DBMS does not need a direct driver to be tested with, being a product supplied by third parties.
\item \textbf{Communication Manager Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Communication manager} in order to test the internal communication capabilities. Especially by testing the ability to invoke methods on the \emph{Data Access Manager} and then allow access to the database to system components.
\item \textbf{Ride Controller Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Ride Controller} and therefore the invocation of all the methods related to the ride operations, and will focus on verifying the interaction with components such as \emph{Communication Manager}, \emph{Notification Helper} and \emph{Google Maps API}.
\item \textbf{Reservation Controller Driver}: as for the \emph{Ride Controller Driver}, this module will be focused on invoking methods exposed by the \emph{Reservation Controller} and therefore the invocation of all the methods related to the reservation operations. In addition, it will be used to test the correct interaction with components such as \emph{Notification Helper} and \emph{Communication Manager}.
\item \textbf{Notification Helper Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Notification Helper} in order to test the proper communication between this component and the gateway forwarding notifications to users, \emph{Push Gateway} and \emph{Email Gateway}.
\item \textbf{Request Manager Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Request Manager} and then verify the correct forwarding of requests coming from the outside to the right components. This module, in detail, check the communication with different components: \emph{Login / Registration Controller}, \emph{Ride Controller}, \emph{Reservation Controller}, \emph{Payment Controller} and finally \emph{Cars Controller}.
\item \textbf{Login/Registration Controller Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Login/Registration Controller} and then verify the correct operation about login and registration.This module will furthermore verify the interaction with \emph{Notification Helper} for submitting notifications and \emph{Communication Manager} for interacting with other components and database.
\item \textbf{Payment Controller Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Payment Controller} in order to check the proper functioning the operations relating to the management of payments. This module will verify the correct connection with the \emph{Communication Manager} and the \emph{Payment Gateway} to test the correct routing of payment notifications to external company.
\item \textbf{Payment Gateway Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Payment Gateway} to test che correct communication with the external company.
\item \textbf{Cars Controller Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Cars Controller} in order to check the correct functioning of the operations relating to the management of sensors and actuators on the machines, as well as functions relating to maintenance. This module will furthermore test the interaction with differents components such as \emph{Communication Manager}, \emph{Maintenance Gateway} to test the correct forwarding of notifications to the maintenance company, and \emph{Collector Data} to ensure the correct communication with cars.
\item \textbf{Maintenance Gateway Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Maintenance Gateway} to verify the correct communication with the maintenance company.
\item \textbf{Collector Data Driver}: the development of this test module will be focused on invoking methods exposed by the \emph{Collector Data} to test the proper communication with sensors and actuators on cars.
\end{itemize}•
\subsection{Test data}
As expressed in section \ref{sec3} (Individual Steps and Test Description) in order to perform the set of tests listed, you must define a data set to cover all variants.
In particular we will need:
\begin{itemize}
\item A set of possible \emph{Request} to test the Request Manager component, providing different features:
\subitem - a null object;
\subitem - more than one correct instance of Request in order to cover all the possible request from the clients.
\item A set of possible query to test the Data Access Manager component, providing different features:
\subitem - a null parameter;
\subitem - a string not correctly parsed in a Query Language;
\subitem - more than one correct query to cover different type of access to the database.
\item A set of possible \emph{Method} to test the Communication Manager component, providing different features:
\subitem - a null object;
\subitem - a Method undefined;
\subitem - more than one correct instance of Method to cover different types of communication.
\item a set of possible \emph{User} to test the Reservation Controller component, providing different features:
\subitem - a null object;
\subitem - a not registered user;
\subitem - more than one valid user with different features like having or not a reservation, being in a ride, being active or suspended from the service.
\item a set of possible password to test the Login/Registration Controller component, providing different features:
\subitem - a null parameter;
\subitem - a not defined password in the database;
\subitem - a valid password.
\item a set of possible driving license to test the Login/Registration Controller component, providing different features:
\subitem - a driving license already registered in the database;
\subitem - a driving license new to the database.
\item a set of possible car plate to test the Reservation Controller and Car Controller components, providing different features:
\subitem - a null parameter;
\subitem - a car plate not listed in the database;
\subitem - a correct car plate.
\item a set of possible ReservationID to test the Reservation Controller component, providing different features:
\subitem - a null parameter;
\subitem - a not existing id;
\subitem - a valid id.
\item a set of possible Reservation to test the Ride Controller component, providing different features:
\subitem - a null parameter;
\subitem - a not existing Reservation in the database;
\subitem - more than one valid Reservation to test the correct management of them.
\item a set of possible Ride to test the Ride Controller component, providing different features:
\subitem - a null parameter;
\subitem - a not registered Ride in the database;
\subitem - a set of valid Ride covering all possible cases such as as being completed, in progress or being just started.
\item a set of possible position to test the Reservation Controller component, providing different features:
\subitem - a null parameter;
\subitem - an invalid position;
\subitem - a set of valid positions related to safe and unsafe area.
\item a set of possible Message to test the Push, Email, Car, Payment and Maintenance gateway components, providing different features:
\subitem - a null parameter;
\subitem - an empty Message;
\subitem - a set of proper defined Messages to be sent via email;
\subitem - a set of proper defined Messages to be sent via push notification;
\subitem - a set of proper defined Messages to the cars of the company;
\subitem - a set of proper defined Messages to be sent to the maintenance system;
\subitem - a set of proper defined Messages to be sent to the payment system.
\item a set of possible Notification to test the Notification Helper component, providing different features:
\subitem - a null parameter;
\subitem - a set of valid Notifications.
\item a set of possible Payment to test the  component, providing different features:
\subitem - a null parameter;
\subitem - a not defined payment;
\subitem - more than one valid payment to cover different possibilities such a payment completed, a pendant one and a payment not well-defined (for example not linked with an existing Ride).
\item a set of possible Car to test the Collector Data and Cars Controller components, providing different features:
\subitem - a null parameter;
\subitem - a not registered car;
\subitem - a valid car.
\item a set of possible unlock Code to test the Car Controller component, providing different features:
\subitem - a null parameter;
\subitem - a set of valid code in order to verify the proper checking of the code linked to a car reservation.
\item a set of possible Maintenance Record to test the Cars Controller component, providing different features:
\subitem - a null parameter;
\subitem - a not registered Maintenance Record;
\subitem - a set of valid records in order to test operations such as the update and the closure by the maintenance.
\end{itemize}•
\addcontentsline{toc}{section}{Used tools}
\section*{Used tools}
\begin{itemize}
\item Github: for version control
\item GoogleDoc: to write the document
\item Draw.io: to create the diagrams
\item \LaTeX: to create the pdf
\end{itemize}
\addcontentsline{toc}{section}{Work hours}
\section*{Work hours} 
\begin{itemize}
\item Emanuele Ricciardelli: $\sim$ 30 hrs.
\item Giorgio Tavecchia: $\sim$ 30 hrs.
\item Francesco Vetr\'o: $\sim$ 30 hrs.
\end{itemize}
\addcontentsline{toc}{section}{Changelog}
\section*{Changelog}
\begin{itemize}
\item v1.1
\subitem - Slight modification to the "Note to the reader" of paragraph Software integration sequence, at the bottom of the last image.
\end{itemize}
\end{document}